# 待办事项

## GORM 缓存改进

### 清理 Worker

为 `GORMCache` 实现后台清理 worker，用于删除过期条目：

- **需求：**

  - 必须使用细粒度批次操作（避免大批量删除）
  - 应持续运行，具有可配置的间隔时间
  - 删除策略：细水长流（例如每批 100 条记录）
  - 应考虑数据库负载并实现背压机制
  - 考虑添加监控指标以观察清理操作

- **实现考虑：**
  - 使用 `updated_at` 时间戳识别过期条目
  - 可配置的过期阈值（例如删除 7 天前的条目）
  - 支持优雅关闭（缓存关闭时停止 worker）
  - 可选：基于数据库性能的自适应批次大小

## 热度统计

### 核心热度追踪功能

实现热度统计机制以跟踪缓存键的访问模式：

- **需求：**

  - 跟踪每个键的访问频率
  - 跟踪最后访问时间戳
  - 衰减机制以降低旧访问的权重
  - 高效的数据结构（例如并发 map 或时间窗口计数器）
  - 可配置的统计数据保留期限

- **需要追踪的指标：**
  - 每个键的命中次数
  - 最后访问时间
  - 访问速率（每时间窗口的命中次数）
  - 可选：区分缓存命中和缓存未命中

### 用于热点 Key 记录的 CacheWrapper

实现一个 `CacheWrapper`，包装现有的 `Cache` 实现以记录热点键：

- **需求：**

  - 包装任何 `Cache[T]` 实现
  - 基于访问模式记录最热的 N 个键
  - 在 `Close()` 时导出热点键列表以供持久化
  - 支持启动时加载热点键进行缓存预热

- **使用场景：**

  - 识别应用重启时应预热哪些键
  - 分析缓存访问模式
  - 优化缓存分配策略

- **API 设计考虑：**

```go
type HotKeyRecorder[T any] struct {
    backend Cache[T]
    stats   *HotnessStats
    topN    int
}

// 关闭时导出热点键
func (h *HotKeyRecorder[T]) Close() (hotKeys []string, err error)

// 加载热点键进行预热
// 注意：批量预热时（如使用 RistrettoCache），可以在所有 Set 操作完成后
// 最后统一调用一次 Wait() 来提升性能
func (h *HotKeyRecorder[T]) WarmUp(ctx context.Context, keys []string) error
```

### 基于热度的流量整形

实现流量整形机制以保护上游服务和数据库：

- **需求：**

  - 根据键的热度区分 fetch 并发度
  - 热点键：更高并发度（为大多数用户提供更快响应） -冷门键：较低并发度（保护数据库稳定性）
  - 渐进式限流以避免突发流量峰值

- **实现策略：**

  - 为热点/冷门键维护独立的 fetch 并发限制
  - 热点键阈值：可配置的百分位数（例如按访问率排名前 20%）
  - 冷门键：使用较小的并发度或速率限制
  - 基于实时访问模式的动态调整

- **配置示例：**

```go
type TrafficShapingConfig struct {
    HotKeyConcurrency  int     // 例如 10
    ColdKeyConcurrency int     // 例如 2
    HotKeyPercentile   float64 // 例如 0.8（前 20%）
}
```

- **优势：**
  - 保护数据库免受冷门键风暴的影响
  - 确保大多数用户（热点键）的良好性能
  - 防止冷门键的慢查询影响热点键性能
  - 高负载下更好的资源分配

## 实现优先级

1. **阶段 1：** 热度统计（其他功能的基础）
2. **阶段 2：** 用于热点键记录的 CacheWrapper（启用缓存预热）
3. **阶段 3：** GORM 清理 Worker（运维稳定性）
4. **阶段 4：** 流量整形（高级优化）

## 其他考虑

- 所有功能应该是可选的且可配置的
- 保持与现有 API 的向后兼容性
- 添加全面的基准测试以衡量开销
- 记录性能特征和权衡取舍
